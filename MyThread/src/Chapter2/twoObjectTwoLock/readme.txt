创建了两个业务对象,所以产生了两个锁

两个线程访问同一个类中的两个不同实例的相同名称的同步方法,效果却是以异步的方式运行的,
当一个线程的获得synchronized的方法时,执行到Thread.sleep()时,这个线程暂时休眠,但是对象锁并没有释放

